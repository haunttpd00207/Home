{"ast":null,"code":"function ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport Vue from '../../utils/vue';\nimport normalizeSlotMixin from '../../mixins/normalize-slot';\nexport var props = {\n  tbodyTransitionProps: {\n    type: Object // default: undefined\n\n  },\n  tbodyTransitionHandlers: {\n    type: Object // default: undefined\n\n  }\n}; // @vue/component\n\nexport var BTbody =\n/*#__PURE__*/\nVue.extend({\n  name: 'BTbody',\n  mixins: [normalizeSlotMixin],\n  inheritAttrs: false,\n  provide: function provide() {\n    return {\n      bvTableRowGroup: this\n    };\n  },\n  inject: {\n    bvTable: {\n      // Sniffed by <b-tr> / <b-td> / <b-th>\n      \"default\": function _default()\n      /* istanbul ignore next */\n      {\n        return {};\n      }\n    }\n  },\n  props: props,\n  computed: {\n    isTbody: function isTbody() {\n      // Sniffed by <b-tr> / <b-td> / <b-th>\n      return true;\n    },\n    isDark: function isDark() {\n      // Sniffed by <b-tr> / <b-td> / <b-th>\n      return this.bvTable.dark;\n    },\n    isStacked: function isStacked() {\n      // Sniffed by <b-tr> / <b-td> / <b-th>\n      return this.bvTable.isStacked;\n    },\n    isResponsive: function isResponsive() {\n      // Sniffed by <b-tr> / <b-td> / <b-th>\n      return this.bvTable.isResponsive;\n    },\n    isStickyHeader: function isStickyHeader() {\n      // Sniffed by <b-tr> / <b-td> / <b-th>\n      // Sticky headers are only supported in thead\n      return false;\n    },\n    tableVariant: function tableVariant()\n    /* istanbul ignore next: Not currently sniffed in tests */\n    {\n      // Sniffed by <b-tr> / <b-td> / <b-th>\n      return this.bvTable.tableVariant;\n    },\n    isTransitionGroup: function isTransitionGroup() {\n      return this.tbodyTransitionProps || this.tbodyTransitionHandlers;\n    },\n    tbodyAttrs: function tbodyAttrs() {\n      return _objectSpread({\n        role: 'rowgroup'\n      }, this.$attrs);\n    },\n    tbodyProps: function tbodyProps() {\n      return this.tbodyTransitionProps ? _objectSpread({}, this.tbodyTransitionProps, {\n        tag: 'tbody'\n      }) : {};\n    },\n    tbodyListeners: function tbodyListeners() {\n      var handlers = this.tbodyTransitionHandlers || {};\n      return _objectSpread({}, this.$listeners, {}, handlers);\n    }\n  },\n  render: function render(h) {\n    return h(this.isTransitionGroup ? 'transition-group' : 'tbody', {\n      props: this.tbodyProps,\n      attrs: this.tbodyAttrs,\n      // Pass down any listeners\n      on: this.tbodyListeners\n    }, this.normalizeSlot('default', {}));\n  }\n});","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar config = require('./config');\n\nvar fromCharCode = String.fromCharCode;\nvar slice = Array.prototype.slice;\nvar toString = Object.prototype.toString;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction isObject(x) {\n  var type = _typeof(x);\n\n  return type === 'function' || type === 'object' && !!x;\n}\n\nexports.isObject = isObject;\n\nfunction isArray(x) {\n  return Array.isArray ? Array.isArray(x) : toString.call(x) === '[object Array]';\n}\n\nexports.isArray = isArray;\n\nfunction isString(x) {\n  return typeof x === 'string' || toString.call(x) === '[object String]';\n}\n\nexports.isString = isString;\n\nfunction getKeys(object) {\n  if (Object.keys) {\n    return Object.keys(object);\n  }\n\n  var keys = [];\n\n  for (var key in object) {\n    if (hasOwnProperty.call(object, key)) {\n      keys[keys.length] = key;\n    }\n  }\n\n  return keys;\n}\n\nexports.getKeys = getKeys;\n\nfunction createBuffer(bits, size) {\n  if (!config.HAS_TYPED) {\n    return new Array(size);\n  }\n\n  switch (bits) {\n    case 8:\n      return new Uint8Array(size);\n\n    case 16:\n      return new Uint16Array(size);\n  }\n}\n\nexports.createBuffer = createBuffer;\n\nfunction stringToBuffer(string) {\n  var length = string.length;\n  var buffer = createBuffer(16, length);\n\n  for (var i = 0; i < length; i++) {\n    buffer[i] = string.charCodeAt(i);\n  }\n\n  return buffer;\n}\n\nexports.stringToBuffer = stringToBuffer;\n\nfunction codeToString_fast(code) {\n  if (config.CAN_CHARCODE_APPLY && config.CAN_CHARCODE_APPLY_TYPED) {\n    var len = code && code.length;\n\n    if (len < config.APPLY_BUFFER_SIZE && config.APPLY_BUFFER_SIZE_OK) {\n      return fromCharCode.apply(null, code);\n    }\n\n    if (config.APPLY_BUFFER_SIZE_OK === null) {\n      try {\n        var s = fromCharCode.apply(null, code);\n\n        if (len > config.APPLY_BUFFER_SIZE) {\n          config.APPLY_BUFFER_SIZE_OK = true;\n        }\n\n        return s;\n      } catch (e) {\n        // Ignore RangeError: arguments too large\n        config.APPLY_BUFFER_SIZE_OK = false;\n      }\n    }\n  }\n\n  return codeToString_chunked(code);\n}\n\nexports.codeToString_fast = codeToString_fast;\n\nfunction codeToString_chunked(code) {\n  var string = '';\n  var length = code && code.length;\n  var i = 0;\n  var sub;\n\n  while (i < length) {\n    if (code.subarray) {\n      sub = code.subarray(i, i + config.APPLY_BUFFER_SIZE);\n    } else {\n      sub = code.slice(i, i + config.APPLY_BUFFER_SIZE);\n    }\n\n    i += config.APPLY_BUFFER_SIZE;\n\n    if (config.APPLY_BUFFER_SIZE_OK) {\n      string += fromCharCode.apply(null, sub);\n      continue;\n    }\n\n    if (config.APPLY_BUFFER_SIZE_OK === null) {\n      try {\n        string += fromCharCode.apply(null, sub);\n\n        if (sub.length > config.APPLY_BUFFER_SIZE) {\n          config.APPLY_BUFFER_SIZE_OK = true;\n        }\n\n        continue;\n      } catch (e) {\n        config.APPLY_BUFFER_SIZE_OK = false;\n      }\n    }\n\n    return codeToString_slow(code);\n  }\n\n  return string;\n}\n\nexports.codeToString_chunked = codeToString_chunked;\n\nfunction codeToString_slow(code) {\n  var string = '';\n  var length = code && code.length;\n\n  for (var i = 0; i < length; i++) {\n    string += fromCharCode(code[i]);\n  }\n\n  return string;\n}\n\nexports.codeToString_slow = codeToString_slow;\n\nfunction stringToCode(string) {\n  var code = [];\n  var len = string && string.length;\n\n  for (var i = 0; i < len; i++) {\n    code[i] = string.charCodeAt(i);\n  }\n\n  return code;\n}\n\nexports.stringToCode = stringToCode;\n\nfunction codeToBuffer(code) {\n  if (config.HAS_TYPED) {\n    // Use Uint16Array for Unicode codepoint.\n    return new Uint16Array(code);\n  } else {\n    if (isArray(code)) {\n      return code;\n    }\n  }\n\n  var length = code && code.length;\n  var buffer = [];\n\n  for (var i = 0; i < length; i++) {\n    buffer[i] = code[i];\n  }\n\n  return buffer;\n}\n\nexports.codeToBuffer = codeToBuffer;\n\nfunction bufferToCode(buffer) {\n  if (isArray(buffer)) {\n    return buffer;\n  }\n\n  return slice.call(buffer);\n}\n\nexports.bufferToCode = bufferToCode; // Base64\n\n/* Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>\n * Version: 1.0\n * LastModified: Dec 25 1999\n * This library is free.  You can redistribute it and/or modify it.\n */\n// -- Masanao Izumo Copyright 1999 \"free\"\n// Modified to add support for Binary Array for Encoding.js\n\nvar base64EncodeChars = [65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47];\nvar base64DecodeChars = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1];\nvar base64EncodePadding = '='.charCodeAt(0);\n\nfunction base64encode(data) {\n  var out, i, len;\n  var c1, c2, c3;\n  len = data && data.length;\n  i = 0;\n  out = [];\n\n  while (i < len) {\n    c1 = data[i++];\n\n    if (i == len) {\n      out[out.length] = base64EncodeChars[c1 >> 2];\n      out[out.length] = base64EncodeChars[(c1 & 0x3) << 4];\n      out[out.length] = base64EncodePadding;\n      out[out.length] = base64EncodePadding;\n      break;\n    }\n\n    c2 = data[i++];\n\n    if (i == len) {\n      out[out.length] = base64EncodeChars[c1 >> 2];\n      out[out.length] = base64EncodeChars[(c1 & 0x3) << 4 | (c2 & 0xF0) >> 4];\n      out[out.length] = base64EncodeChars[(c2 & 0xF) << 2];\n      out[out.length] = base64EncodePadding;\n      break;\n    }\n\n    c3 = data[i++];\n    out[out.length] = base64EncodeChars[c1 >> 2];\n    out[out.length] = base64EncodeChars[(c1 & 0x3) << 4 | (c2 & 0xF0) >> 4];\n    out[out.length] = base64EncodeChars[(c2 & 0xF) << 2 | (c3 & 0xC0) >> 6];\n    out[out.length] = base64EncodeChars[c3 & 0x3F];\n  }\n\n  return codeToString_fast(out);\n}\n\nexports.base64encode = base64encode;\n\nfunction base64decode(str) {\n  var c1, c2, c3, c4;\n  var i, len, out;\n  len = str && str.length;\n  i = 0;\n  out = [];\n\n  while (i < len) {\n    /* c1 */\n    do {\n      c1 = base64DecodeChars[str.charCodeAt(i++) & 0xFF];\n    } while (i < len && c1 == -1);\n\n    if (c1 == -1) {\n      break;\n    }\n    /* c2 */\n\n\n    do {\n      c2 = base64DecodeChars[str.charCodeAt(i++) & 0xFF];\n    } while (i < len && c2 == -1);\n\n    if (c2 == -1) {\n      break;\n    }\n\n    out[out.length] = c1 << 2 | (c2 & 0x30) >> 4;\n    /* c3 */\n\n    do {\n      c3 = str.charCodeAt(i++) & 0xFF;\n\n      if (c3 == 61) {\n        return out;\n      }\n\n      c3 = base64DecodeChars[c3];\n    } while (i < len && c3 == -1);\n\n    if (c3 == -1) {\n      break;\n    }\n\n    out[out.length] = (c2 & 0xF) << 4 | (c3 & 0x3C) >> 2;\n    /* c4 */\n\n    do {\n      c4 = str.charCodeAt(i++) & 0xFF;\n\n      if (c4 == 61) {\n        return out;\n      }\n\n      c4 = base64DecodeChars[c4];\n    } while (i < len && c4 == -1);\n\n    if (c4 == -1) {\n      break;\n    }\n\n    out[out.length] = (c3 & 0x03) << 6 | c4;\n  }\n\n  return out;\n}\n\nexports.base64decode = base64decode;","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"var config = require('./config');\n\nvar util = require('./util');\n\nvar EncodingDetect = require('./encoding-detect');\n\nvar EncodingTable = require('./encoding-table');\n/**\n * JIS to SJIS\n */\n\n\nfunction JISToSJIS(data) {\n  var results = [];\n  var index = 0;\n  var i = 0;\n  var len = data && data.length;\n  var b1, b2;\n\n  for (; i < len; i++) {\n    // escape sequence\n    while (data[i] === 0x1B) {\n      if (data[i + 1] === 0x24 && data[i + 2] === 0x42 || data[i + 1] === 0x24 && data[i + 2] === 0x40) {\n        index = 1;\n      } else if (data[i + 1] === 0x28 && data[i + 2] === 0x49) {\n        index = 2;\n      } else if (data[i + 1] === 0x24 && data[i + 2] === 0x28 && data[i + 3] === 0x44) {\n        index = 3;\n        i++;\n      } else {\n        index = 0;\n      }\n\n      i += 3;\n\n      if (data[i] === void 0) {\n        return results;\n      }\n    }\n\n    if (index === 1) {\n      b1 = data[i];\n      b2 = data[++i];\n\n      if (b1 & 0x01) {\n        b1 >>= 1;\n\n        if (b1 < 0x2F) {\n          b1 += 0x71;\n        } else {\n          b1 -= 0x4F;\n        }\n\n        if (b2 > 0x5F) {\n          b2 += 0x20;\n        } else {\n          b2 += 0x1F;\n        }\n      } else {\n        b1 >>= 1;\n\n        if (b1 <= 0x2F) {\n          b1 += 0x70;\n        } else {\n          b1 -= 0x50;\n        }\n\n        b2 += 0x7E;\n      }\n\n      results[results.length] = b1 & 0xFF;\n      results[results.length] = b2 & 0xFF;\n    } else if (index === 2) {\n      results[results.length] = data[i] + 0x80 & 0xFF;\n    } else if (index === 3) {\n      // Shift_JIS cannot convert JIS X 0212:1990.\n      results[results.length] = config.UNKNOWN_CHARACTER;\n    } else {\n      results[results.length] = data[i] & 0xFF;\n    }\n  }\n\n  return results;\n}\n\nexports.JISToSJIS = JISToSJIS;\n/**\n * JIS to EUCJP\n */\n\nfunction JISToEUCJP(data) {\n  var results = [];\n  var index = 0;\n  var len = data && data.length;\n  var i = 0;\n\n  for (; i < len; i++) {\n    // escape sequence\n    while (data[i] === 0x1B) {\n      if (data[i + 1] === 0x24 && data[i + 2] === 0x42 || data[i + 1] === 0x24 && data[i + 2] === 0x40) {\n        index = 1;\n      } else if (data[i + 1] === 0x28 && data[i + 2] === 0x49) {\n        index = 2;\n      } else if (data[i + 1] === 0x24 && data[i + 2] === 0x28 && data[i + 3] === 0x44) {\n        index = 3;\n        i++;\n      } else {\n        index = 0;\n      }\n\n      i += 3;\n\n      if (data[i] === void 0) {\n        return results;\n      }\n    }\n\n    if (index === 1) {\n      results[results.length] = data[i] + 0x80 & 0xFF;\n      results[results.length] = data[++i] + 0x80 & 0xFF;\n    } else if (index === 2) {\n      results[results.length] = 0x8E;\n      results[results.length] = data[i] + 0x80 & 0xFF;\n    } else if (index === 3) {\n      results[results.length] = 0x8F;\n      results[results.length] = data[i] + 0x80 & 0xFF;\n      results[results.length] = data[++i] + 0x80 & 0xFF;\n    } else {\n      results[results.length] = data[i] & 0xFF;\n    }\n  }\n\n  return results;\n}\n\nexports.JISToEUCJP = JISToEUCJP;\n/**\n * SJIS to JIS\n */\n\nfunction SJISToJIS(data) {\n  var results = [];\n  var index = 0;\n  var len = data && data.length;\n  var i = 0;\n  var b1, b2;\n  var esc = [0x1B, 0x28, 0x42, 0x1B, 0x24, 0x42, 0x1B, 0x28, 0x49];\n\n  for (; i < len; i++) {\n    b1 = data[i];\n\n    if (b1 >= 0xA1 && b1 <= 0xDF) {\n      if (index !== 2) {\n        index = 2;\n        results[results.length] = esc[6];\n        results[results.length] = esc[7];\n        results[results.length] = esc[8];\n      }\n\n      results[results.length] = b1 - 0x80 & 0xFF;\n    } else if (b1 >= 0x80) {\n      if (index !== 1) {\n        index = 1;\n        results[results.length] = esc[3];\n        results[results.length] = esc[4];\n        results[results.length] = esc[5];\n      }\n\n      b1 <<= 1;\n      b2 = data[++i];\n\n      if (b2 < 0x9F) {\n        if (b1 < 0x13F) {\n          b1 -= 0xE1;\n        } else {\n          b1 -= 0x61;\n        }\n\n        if (b2 > 0x7E) {\n          b2 -= 0x20;\n        } else {\n          b2 -= 0x1F;\n        }\n      } else {\n        if (b1 < 0x13F) {\n          b1 -= 0xE0;\n        } else {\n          b1 -= 0x60;\n        }\n\n        b2 -= 0x7E;\n      }\n\n      results[results.length] = b1 & 0xFF;\n      results[results.length] = b2 & 0xFF;\n    } else {\n      if (index !== 0) {\n        index = 0;\n        results[results.length] = esc[0];\n        results[results.length] = esc[1];\n        results[results.length] = esc[2];\n      }\n\n      results[results.length] = b1 & 0xFF;\n    }\n  }\n\n  if (index !== 0) {\n    results[results.length] = esc[0];\n    results[results.length] = esc[1];\n    results[results.length] = esc[2];\n  }\n\n  return results;\n}\n\nexports.SJISToJIS = SJISToJIS;\n/**\n * SJIS to EUCJP\n */\n\nfunction SJISToEUCJP(data) {\n  var results = [];\n  var len = data && data.length;\n  var i = 0;\n  var b1, b2;\n\n  for (; i < len; i++) {\n    b1 = data[i];\n\n    if (b1 >= 0xA1 && b1 <= 0xDF) {\n      results[results.length] = 0x8E;\n      results[results.length] = b1;\n    } else if (b1 >= 0x81) {\n      b2 = data[++i];\n      b1 <<= 1;\n\n      if (b2 < 0x9F) {\n        if (b1 < 0x13F) {\n          b1 -= 0x61;\n        } else {\n          b1 -= 0xE1;\n        }\n\n        if (b2 > 0x7E) {\n          b2 += 0x60;\n        } else {\n          b2 += 0x61;\n        }\n      } else {\n        if (b1 < 0x13F) {\n          b1 -= 0x60;\n        } else {\n          b1 -= 0xE0;\n        }\n\n        b2 += 0x02;\n      }\n\n      results[results.length] = b1 & 0xFF;\n      results[results.length] = b2 & 0xFF;\n    } else {\n      results[results.length] = b1 & 0xFF;\n    }\n  }\n\n  return results;\n}\n\nexports.SJISToEUCJP = SJISToEUCJP;\n/**\n * EUCJP to JIS\n */\n\nfunction EUCJPToJIS(data) {\n  var results = [];\n  var index = 0;\n  var len = data && data.length;\n  var i = 0;\n  var b; // escape sequence\n\n  var esc = [0x1B, 0x28, 0x42, 0x1B, 0x24, 0x42, 0x1B, 0x28, 0x49, 0x1B, 0x24, 0x28, 0x44];\n\n  for (; i < len; i++) {\n    b = data[i];\n\n    if (b === 0x8E) {\n      if (index !== 2) {\n        index = 2;\n        results[results.length] = esc[6];\n        results[results.length] = esc[7];\n        results[results.length] = esc[8];\n      }\n\n      results[results.length] = data[++i] - 0x80 & 0xFF;\n    } else if (b === 0x8F) {\n      if (index !== 3) {\n        index = 3;\n        results[results.length] = esc[9];\n        results[results.length] = esc[10];\n        results[results.length] = esc[11];\n        results[results.length] = esc[12];\n      }\n\n      results[results.length] = data[++i] - 0x80 & 0xFF;\n      results[results.length] = data[++i] - 0x80 & 0xFF;\n    } else if (b > 0x8E) {\n      if (index !== 1) {\n        index = 1;\n        results[results.length] = esc[3];\n        results[results.length] = esc[4];\n        results[results.length] = esc[5];\n      }\n\n      results[results.length] = b - 0x80 & 0xFF;\n      results[results.length] = data[++i] - 0x80 & 0xFF;\n    } else {\n      if (index !== 0) {\n        index = 0;\n        results[results.length] = esc[0];\n        results[results.length] = esc[1];\n        results[results.length] = esc[2];\n      }\n\n      results[results.length] = b & 0xFF;\n    }\n  }\n\n  if (index !== 0) {\n    results[results.length] = esc[0];\n    results[results.length] = esc[1];\n    results[results.length] = esc[2];\n  }\n\n  return results;\n}\n\nexports.EUCJPToJIS = EUCJPToJIS;\n/**\n * EUCJP to SJIS\n */\n\nfunction EUCJPToSJIS(data) {\n  var results = [];\n  var len = data && data.length;\n  var i = 0;\n  var b1, b2;\n\n  for (; i < len; i++) {\n    b1 = data[i];\n\n    if (b1 === 0x8F) {\n      results[results.length] = config.UNKNOWN_CHARACTER;\n      i += 2;\n    } else if (b1 > 0x8E) {\n      b2 = data[++i];\n\n      if (b1 & 0x01) {\n        b1 >>= 1;\n\n        if (b1 < 0x6F) {\n          b1 += 0x31;\n        } else {\n          b1 += 0x71;\n        }\n\n        if (b2 > 0xDF) {\n          b2 -= 0x60;\n        } else {\n          b2 -= 0x61;\n        }\n      } else {\n        b1 >>= 1;\n\n        if (b1 <= 0x6F) {\n          b1 += 0x30;\n        } else {\n          b1 += 0x70;\n        }\n\n        b2 -= 0x02;\n      }\n\n      results[results.length] = b1 & 0xFF;\n      results[results.length] = b2 & 0xFF;\n    } else if (b1 === 0x8E) {\n      results[results.length] = data[++i] & 0xFF;\n    } else {\n      results[results.length] = b1 & 0xFF;\n    }\n  }\n\n  return results;\n}\n\nexports.EUCJPToSJIS = EUCJPToSJIS;\n/**\n * SJIS To UTF-8\n */\n\nfunction SJISToUTF8(data) {\n  config.init_JIS_TO_UTF8_TABLE();\n  var results = [];\n  var i = 0;\n  var len = data && data.length;\n  var b, b1, b2, u2, u3, jis, utf8;\n\n  for (; i < len; i++) {\n    b = data[i];\n\n    if (b >= 0xA1 && b <= 0xDF) {\n      b2 = b - 0x40;\n      u2 = 0xBC | b2 >> 6 & 0x03;\n      u3 = 0x80 | b2 & 0x3F;\n      results[results.length] = 0xEF;\n      results[results.length] = u2 & 0xFF;\n      results[results.length] = u3 & 0xFF;\n    } else if (b >= 0x80) {\n      b1 = b << 1;\n      b2 = data[++i];\n\n      if (b2 < 0x9F) {\n        if (b1 < 0x13F) {\n          b1 -= 0xE1;\n        } else {\n          b1 -= 0x61;\n        }\n\n        if (b2 > 0x7E) {\n          b2 -= 0x20;\n        } else {\n          b2 -= 0x1F;\n        }\n      } else {\n        if (b1 < 0x13F) {\n          b1 -= 0xE0;\n        } else {\n          b1 -= 0x60;\n        }\n\n        b2 -= 0x7E;\n      }\n\n      b1 &= 0xFF;\n      jis = (b1 << 8) + b2;\n      utf8 = EncodingTable.JIS_TO_UTF8_TABLE[jis];\n\n      if (utf8 === void 0) {\n        results[results.length] = config.UNKNOWN_CHARACTER;\n      } else {\n        if (utf8 < 0xFFFF) {\n          results[results.length] = utf8 >> 8 & 0xFF;\n          results[results.length] = utf8 & 0xFF;\n        } else {\n          results[results.length] = utf8 >> 16 & 0xFF;\n          results[results.length] = utf8 >> 8 & 0xFF;\n          results[results.length] = utf8 & 0xFF;\n        }\n      }\n    } else {\n      results[results.length] = data[i] & 0xFF;\n    }\n  }\n\n  return results;\n}\n\nexports.SJISToUTF8 = SJISToUTF8;\n/**\n * EUC-JP to UTF-8\n */\n\nfunction EUCJPToUTF8(data) {\n  config.init_JIS_TO_UTF8_TABLE();\n  var results = [];\n  var i = 0;\n  var len = data && data.length;\n  var b, b2, u2, u3, j2, j3, jis, utf8;\n\n  for (; i < len; i++) {\n    b = data[i];\n\n    if (b === 0x8E) {\n      b2 = data[++i] - 0x40;\n      u2 = 0xBC | b2 >> 6 & 0x03;\n      u3 = 0x80 | b2 & 0x3F;\n      results[results.length] = 0xEF;\n      results[results.length] = u2 & 0xFF;\n      results[results.length] = u3 & 0xFF;\n    } else if (b === 0x8F) {\n      j2 = data[++i] - 0x80;\n      j3 = data[++i] - 0x80;\n      jis = (j2 << 8) + j3;\n      utf8 = EncodingTable.JISX0212_TO_UTF8_TABLE[jis];\n\n      if (utf8 === void 0) {\n        results[results.length] = config.UNKNOWN_CHARACTER;\n      } else {\n        if (utf8 < 0xFFFF) {\n          results[results.length] = utf8 >> 8 & 0xFF;\n          results[results.length] = utf8 & 0xFF;\n        } else {\n          results[results.length] = utf8 >> 16 & 0xFF;\n          results[results.length] = utf8 >> 8 & 0xFF;\n          results[results.length] = utf8 & 0xFF;\n        }\n      }\n    } else if (b >= 0x80) {\n      jis = (b - 0x80 << 8) + (data[++i] - 0x80);\n      utf8 = EncodingTable.JIS_TO_UTF8_TABLE[jis];\n\n      if (utf8 === void 0) {\n        results[results.length] = config.UNKNOWN_CHARACTER;\n      } else {\n        if (utf8 < 0xFFFF) {\n          results[results.length] = utf8 >> 8 & 0xFF;\n          results[results.length] = utf8 & 0xFF;\n        } else {\n          results[results.length] = utf8 >> 16 & 0xFF;\n          results[results.length] = utf8 >> 8 & 0xFF;\n          results[results.length] = utf8 & 0xFF;\n        }\n      }\n    } else {\n      results[results.length] = data[i] & 0xFF;\n    }\n  }\n\n  return results;\n}\n\nexports.EUCJPToUTF8 = EUCJPToUTF8;\n/**\n * JIS to UTF-8\n */\n\nfunction JISToUTF8(data) {\n  config.init_JIS_TO_UTF8_TABLE();\n  var results = [];\n  var index = 0;\n  var i = 0;\n  var len = data && data.length;\n  var b2, u2, u3, jis, utf8;\n\n  for (; i < len; i++) {\n    while (data[i] === 0x1B) {\n      if (data[i + 1] === 0x24 && data[i + 2] === 0x42 || data[i + 1] === 0x24 && data[i + 2] === 0x40) {\n        index = 1;\n      } else if (data[i + 1] === 0x28 && data[i + 2] === 0x49) {\n        index = 2;\n      } else if (data[i + 1] === 0x24 && data[i + 2] === 0x28 && data[i + 3] === 0x44) {\n        index = 3;\n        i++;\n      } else {\n        index = 0;\n      }\n\n      i += 3;\n\n      if (data[i] === void 0) {\n        return results;\n      }\n    }\n\n    if (index === 1) {\n      jis = (data[i] << 8) + data[++i];\n      utf8 = EncodingTable.JIS_TO_UTF8_TABLE[jis];\n\n      if (utf8 === void 0) {\n        results[results.length] = config.UNKNOWN_CHARACTER;\n      } else {\n        if (utf8 < 0xFFFF) {\n          results[results.length] = utf8 >> 8 & 0xFF;\n          results[results.length] = utf8 & 0xFF;\n        } else {\n          results[results.length] = utf8 >> 16 & 0xFF;\n          results[results.length] = utf8 >> 8 & 0xFF;\n          results[results.length] = utf8 & 0xFF;\n        }\n      }\n    } else if (index === 2) {\n      b2 = data[i] + 0x40;\n      u2 = 0xBC | b2 >> 6 & 0x03;\n      u3 = 0x80 | b2 & 0x3F;\n      results[results.length] = 0xEF;\n      results[results.length] = u2 & 0xFF;\n      results[results.length] = u3 & 0xFF;\n    } else if (index === 3) {\n      jis = (data[i] << 8) + data[++i];\n      utf8 = EncodingTable.JISX0212_TO_UTF8_TABLE[jis];\n\n      if (utf8 === void 0) {\n        results[results.length] = config.UNKNOWN_CHARACTER;\n      } else {\n        if (utf8 < 0xFFFF) {\n          results[results.length] = utf8 >> 8 & 0xFF;\n          results[results.length] = utf8 & 0xFF;\n        } else {\n          results[results.length] = utf8 >> 16 & 0xFF;\n          results[results.length] = utf8 >> 8 & 0xFF;\n          results[results.length] = utf8 & 0xFF;\n        }\n      }\n    } else {\n      results[results.length] = data[i] & 0xFF;\n    }\n  }\n\n  return results;\n}\n\nexports.JISToUTF8 = JISToUTF8;\n/**\n * UTF-8 to SJIS\n */\n\nfunction UTF8ToSJIS(data) {\n  var results = [];\n  var i = 0;\n  var len = data && data.length;\n  var b, b1, b2, utf8, jis;\n\n  for (; i < len; i++) {\n    b = data[i];\n\n    if (b >= 0x80) {\n      if (b <= 0xDF) {\n        // 2 bytes\n        utf8 = (b << 8) + data[++i];\n      } else {\n        // 3 bytes\n        utf8 = (b << 16) + (data[++i] << 8) + (data[++i] & 0xFF);\n      }\n\n      jis = EncodingTable.UTF8_TO_JIS_TABLE[utf8];\n\n      if (jis === void 0) {\n        results[results.length] = config.UNKNOWN_CHARACTER;\n      } else {\n        if (jis < 0xFF) {\n          results[results.length] = jis + 0x80;\n        } else {\n          if (jis > 0x10000) {\n            jis -= 0x10000;\n          }\n\n          b1 = jis >> 8;\n          b2 = jis & 0xFF;\n\n          if (b1 & 0x01) {\n            b1 >>= 1;\n\n            if (b1 < 0x2F) {\n              b1 += 0x71;\n            } else {\n              b1 -= 0x4F;\n            }\n\n            if (b2 > 0x5F) {\n              b2 += 0x20;\n            } else {\n              b2 += 0x1F;\n            }\n          } else {\n            b1 >>= 1;\n\n            if (b1 <= 0x2F) {\n              b1 += 0x70;\n            } else {\n              b1 -= 0x50;\n            }\n\n            b2 += 0x7E;\n          }\n\n          results[results.length] = b1 & 0xFF;\n          results[results.length] = b2 & 0xFF;\n        }\n      }\n    } else {\n      results[results.length] = data[i] & 0xFF;\n    }\n  }\n\n  return results;\n}\n\nexports.UTF8ToSJIS = UTF8ToSJIS;\n/**\n * UTF-8 to EUC-JP\n */\n\nfunction UTF8ToEUCJP(data) {\n  var results = [];\n  var i = 0;\n  var len = data && data.length;\n  var b, utf8, jis;\n\n  for (; i < len; i++) {\n    b = data[i];\n\n    if (b >= 0x80) {\n      if (b <= 0xDF) {\n        utf8 = (data[i++] << 8) + data[i];\n      } else {\n        utf8 = (data[i++] << 16) + (data[i++] << 8) + (data[i] & 0xFF);\n      }\n\n      jis = EncodingTable.UTF8_TO_JIS_TABLE[utf8];\n\n      if (jis === void 0) {\n        jis = EncodingTable.UTF8_TO_JISX0212_TABLE[utf8];\n\n        if (jis === void 0) {\n          results[results.length] = config.UNKNOWN_CHARACTER;\n        } else {\n          results[results.length] = 0x8F;\n          results[results.length] = (jis >> 8) - 0x80 & 0xFF;\n          results[results.length] = (jis & 0xFF) - 0x80 & 0xFF;\n        }\n      } else {\n        if (jis > 0x10000) {\n          jis -= 0x10000;\n        }\n\n        if (jis < 0xFF) {\n          results[results.length] = 0x8E;\n          results[results.length] = jis - 0x80 & 0xFF;\n        } else {\n          results[results.length] = (jis >> 8) - 0x80 & 0xFF;\n          results[results.length] = (jis & 0xFF) - 0x80 & 0xFF;\n        }\n      }\n    } else {\n      results[results.length] = data[i] & 0xFF;\n    }\n  }\n\n  return results;\n}\n\nexports.UTF8ToEUCJP = UTF8ToEUCJP;\n/**\n * UTF-8 to JIS\n */\n\nfunction UTF8ToJIS(data) {\n  var results = [];\n  var index = 0;\n  var len = data && data.length;\n  var i = 0;\n  var b, utf8, jis;\n  var esc = [0x1B, 0x28, 0x42, 0x1B, 0x24, 0x42, 0x1B, 0x28, 0x49, 0x1B, 0x24, 0x28, 0x44];\n\n  for (; i < len; i++) {\n    b = data[i];\n\n    if (b < 0x80) {\n      if (index !== 0) {\n        index = 0;\n        results[results.length] = esc[0];\n        results[results.length] = esc[1];\n        results[results.length] = esc[2];\n      }\n\n      results[results.length] = b & 0xFF;\n    } else {\n      if (b <= 0xDF) {\n        utf8 = (data[i] << 8) + data[++i];\n      } else {\n        utf8 = (data[i] << 16) + (data[++i] << 8) + data[++i];\n      }\n\n      jis = EncodingTable.UTF8_TO_JIS_TABLE[utf8];\n\n      if (jis === void 0) {\n        jis = EncodingTable.UTF8_TO_JISX0212_TABLE[utf8];\n\n        if (jis === void 0) {\n          if (index !== 0) {\n            index = 0;\n            results[results.length] = esc[0];\n            results[results.length] = esc[1];\n            results[results.length] = esc[2];\n          }\n\n          results[results.length] = config.UNKNOWN_CHARACTER;\n        } else {\n          // JIS X 0212:1990\n          if (index !== 3) {\n            index = 3;\n            results[results.length] = esc[9];\n            results[results.length] = esc[10];\n            results[results.length] = esc[11];\n            results[results.length] = esc[12];\n          }\n\n          results[results.length] = jis >> 8 & 0xFF;\n          results[results.length] = jis & 0xFF;\n        }\n      } else {\n        if (jis > 0x10000) {\n          jis -= 0x10000;\n        }\n\n        if (jis < 0xFF) {\n          // Halfwidth Katakana\n          if (index !== 2) {\n            index = 2;\n            results[results.length] = esc[6];\n            results[results.length] = esc[7];\n            results[results.length] = esc[8];\n          }\n\n          results[results.length] = jis & 0xFF;\n        } else {\n          if (index !== 1) {\n            index = 1;\n            results[results.length] = esc[3];\n            results[results.length] = esc[4];\n            results[results.length] = esc[5];\n          }\n\n          results[results.length] = jis >> 8 & 0xFF;\n          results[results.length] = jis & 0xFF;\n        }\n      }\n    }\n  }\n\n  if (index !== 0) {\n    results[results.length] = esc[0];\n    results[results.length] = esc[1];\n    results[results.length] = esc[2];\n  }\n\n  return results;\n}\n\nexports.UTF8ToJIS = UTF8ToJIS;\n/**\n * UTF-16 (JavaScript Unicode array) to UTF-8\n */\n\nfunction UNICODEToUTF8(data) {\n  var results = [];\n  var i = 0;\n  var len = data && data.length;\n  var c, second;\n\n  for (; i < len; i++) {\n    c = data[i]; // high surrogate\n\n    if (c >= 0xD800 && c <= 0xDBFF && i + 1 < len) {\n      second = data[i + 1]; // low surrogate\n\n      if (second >= 0xDC00 && second <= 0xDFFF) {\n        c = (c - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n        i++;\n      }\n    }\n\n    if (c < 0x80) {\n      results[results.length] = c;\n    } else if (c < 0x800) {\n      results[results.length] = 0xC0 | c >> 6 & 0x1F;\n      results[results.length] = 0x80 | c & 0x3F;\n    } else if (c < 0x10000) {\n      results[results.length] = 0xE0 | c >> 12 & 0xF;\n      results[results.length] = 0x80 | c >> 6 & 0x3F;\n      results[results.length] = 0x80 | c & 0x3F;\n    } else if (c < 0x200000) {\n      results[results.length] = 0xF0 | c >> 18 & 0xF;\n      results[results.length] = 0x80 | c >> 12 & 0x3F;\n      results[results.length] = 0x80 | c >> 6 & 0x3F;\n      results[results.length] = 0x80 | c & 0x3F;\n    }\n  }\n\n  return results;\n}\n\nexports.UNICODEToUTF8 = UNICODEToUTF8;\n/**\n * UTF-8 to UTF-16 (JavaScript Unicode array)\n */\n\nfunction UTF8ToUNICODE(data) {\n  var results = [];\n  var i = 0;\n  var len = data && data.length;\n  var n, c, c2, c3, c4, code;\n\n  while (i < len) {\n    c = data[i++];\n    n = c >> 4;\n\n    if (n >= 0 && n <= 7) {\n      // 0xxx xxxx\n      code = c;\n    } else if (n === 12 || n === 13) {\n      // 110x xxxx\n      // 10xx xxxx\n      c2 = data[i++];\n      code = (c & 0x1F) << 6 | c2 & 0x3F;\n    } else if (n === 14) {\n      // 1110 xxxx\n      // 10xx xxxx\n      // 10xx xxxx\n      c2 = data[i++];\n      c3 = data[i++];\n      code = (c & 0x0F) << 12 | (c2 & 0x3F) << 6 | c3 & 0x3F;\n    } else if (n === 15) {\n      // 1111 0xxx\n      // 10xx xxxx\n      // 10xx xxxx\n      // 10xx xxxx\n      c2 = data[i++];\n      c3 = data[i++];\n      c4 = data[i++];\n      code = (c & 0x7) << 18 | (c2 & 0x3F) << 12 | (c3 & 0x3F) << 6 | c4 & 0x3F;\n    }\n\n    if (code <= 0xFFFF) {\n      results[results.length] = code;\n    } else {\n      // Split in surrogate halves\n      code -= 0x10000;\n      results[results.length] = (code >> 10) + 0xD800; // High surrogate\n\n      results[results.length] = code % 0x400 + 0xDC00; // Low surrogate\n    }\n  }\n\n  return results;\n}\n\nexports.UTF8ToUNICODE = UTF8ToUNICODE;\n/**\n * UTF-16 (JavaScript Unicode array) to UTF-16\n *\n * UTF-16BE (big-endian)\n * Note: this function does not prepend the BOM by default.\n *\n * RFC 2781 4.3 Interpreting text labelled as UTF-16\n *   If the first two octets of the text is not 0xFE followed by\n *   0xFF, and is not 0xFF followed by 0xFE, then the text SHOULD be\n *   interpreted as being big-endian.\n *\n * @link https://www.ietf.org/rfc/rfc2781.txt\n * UTF-16, an encoding of ISO 10646\n */\n\nfunction UNICODEToUTF16(data, options) {\n  var results;\n\n  if (options && options.bom) {\n    var optBom = options.bom;\n\n    if (!util.isString(optBom)) {\n      optBom = 'BE';\n    }\n\n    var bom, utf16;\n\n    if (optBom.charAt(0).toUpperCase() === 'B') {\n      // Big-endian\n      bom = [0xFE, 0xFF];\n      utf16 = UNICODEToUTF16BE(data);\n    } else {\n      // Little-endian\n      bom = [0xFF, 0xFE];\n      utf16 = UNICODEToUTF16LE(data);\n    }\n\n    results = [];\n    results[0] = bom[0];\n    results[1] = bom[1];\n\n    for (var i = 0, len = utf16.length; i < len; i++) {\n      results[results.length] = utf16[i];\n    }\n  } else {\n    // Without BOM: Convert as BE (SHOULD).\n    results = UNICODEToUTF16BE(data);\n  }\n\n  return results;\n}\n\nexports.UNICODEToUTF16 = UNICODEToUTF16;\n/**\n * UTF-16 (JavaScript Unicode array) to UTF-16BE\n *\n * @link https://www.ietf.org/rfc/rfc2781.txt\n * UTF-16, an encoding of ISO 10646\n */\n\nfunction UNICODEToUTF16BE(data) {\n  var results = [];\n  var i = 0;\n  var len = data && data.length;\n  var c;\n\n  while (i < len) {\n    c = data[i++];\n\n    if (c <= 0xFF) {\n      results[results.length] = 0;\n      results[results.length] = c;\n    } else if (c <= 0xFFFF) {\n      results[results.length] = c >> 8 & 0xFF;\n      results[results.length] = c & 0xFF;\n    }\n  }\n\n  return results;\n}\n\nexports.UNICODEToUTF16BE = UNICODEToUTF16BE;\n/**\n * UTF-16 (JavaScript Unicode array) to UTF-16LE\n *\n * @link https://www.ietf.org/rfc/rfc2781.txt\n * UTF-16, an encoding of ISO 10646\n */\n\nfunction UNICODEToUTF16LE(data) {\n  var results = [];\n  var i = 0;\n  var len = data && data.length;\n  var c;\n\n  while (i < len) {\n    c = data[i++];\n\n    if (c <= 0xFF) {\n      results[results.length] = c;\n      results[results.length] = 0;\n    } else if (c <= 0xFFFF) {\n      results[results.length] = c & 0xFF;\n      results[results.length] = c >> 8 & 0xFF;\n    }\n  }\n\n  return results;\n}\n\nexports.UNICODEToUTF16LE = UNICODEToUTF16LE;\n/**\n * UTF-16BE to UTF-16 (JavaScript Unicode array)\n *\n * @link https://www.ietf.org/rfc/rfc2781.txt\n * UTF-16, an encoding of ISO 10646\n */\n\nfunction UTF16BEToUNICODE(data) {\n  var results = [];\n  var i = 0;\n  var len = data && data.length;\n  var c1, c2;\n\n  if (len >= 2 && (data[0] === 0xFE && data[1] === 0xFF || data[0] === 0xFF && data[1] === 0xFE)) {\n    i = 2;\n  }\n\n  while (i < len) {\n    c1 = data[i++];\n    c2 = data[i++];\n\n    if (c1 === 0) {\n      results[results.length] = c2;\n    } else {\n      results[results.length] = (c1 & 0xFF) << 8 | c2 & 0xFF;\n    }\n  }\n\n  return results;\n}\n\nexports.UTF16BEToUNICODE = UTF16BEToUNICODE;\n/**\n * UTF-16LE to UTF-16 (JavaScript Unicode array)\n *\n * @link https://www.ietf.org/rfc/rfc2781.txt\n * UTF-16, an encoding of ISO 10646\n */\n\nfunction UTF16LEToUNICODE(data) {\n  var results = [];\n  var i = 0;\n  var len = data && data.length;\n  var c1, c2;\n\n  if (len >= 2 && (data[0] === 0xFE && data[1] === 0xFF || data[0] === 0xFF && data[1] === 0xFE)) {\n    i = 2;\n  }\n\n  while (i < len) {\n    c1 = data[i++];\n    c2 = data[i++];\n\n    if (c2 === 0) {\n      results[results.length] = c1;\n    } else {\n      results[results.length] = (c2 & 0xFF) << 8 | c1 & 0xFF;\n    }\n  }\n\n  return results;\n}\n\nexports.UTF16LEToUNICODE = UTF16LEToUNICODE;\n/**\n * UTF-16 to UTF-16 (JavaScript Unicode array)\n *\n * @link https://www.ietf.org/rfc/rfc2781.txt\n * UTF-16, an encoding of ISO 10646\n */\n\nfunction UTF16ToUNICODE(data) {\n  var results = [];\n  var i = 0;\n  var len = data && data.length;\n  var isLE = false;\n  var first = true;\n  var c1, c2;\n\n  while (i < len) {\n    c1 = data[i++];\n    c2 = data[i++];\n\n    if (first && i === 2) {\n      first = false;\n\n      if (c1 === 0xFE && c2 === 0xFF) {\n        isLE = false;\n      } else if (c1 === 0xFF && c2 === 0xFE) {\n        // Little-endian\n        isLE = true;\n      } else {\n        isLE = EncodingDetect.isUTF16LE(data);\n        i = 0;\n      }\n\n      continue;\n    }\n\n    if (isLE) {\n      if (c2 === 0) {\n        results[results.length] = c1;\n      } else {\n        results[results.length] = (c2 & 0xFF) << 8 | c1 & 0xFF;\n      }\n    } else {\n      if (c1 === 0) {\n        results[results.length] = c2;\n      } else {\n        results[results.length] = (c1 & 0xFF) << 8 | c2 & 0xFF;\n      }\n    }\n  }\n\n  return results;\n}\n\nexports.UTF16ToUNICODE = UTF16ToUNICODE;\n/**\n * UTF-16 to UTF-16BE\n */\n\nfunction UTF16ToUTF16BE(data) {\n  var results = [];\n  var i = 0;\n  var len = data && data.length;\n  var isLE = false;\n  var first = true;\n  var c1, c2;\n\n  while (i < len) {\n    c1 = data[i++];\n    c2 = data[i++];\n\n    if (first && i === 2) {\n      first = false;\n\n      if (c1 === 0xFE && c2 === 0xFF) {\n        isLE = false;\n      } else if (c1 === 0xFF && c2 === 0xFE) {\n        // Little-endian\n        isLE = true;\n      } else {\n        isLE = EncodingDetect.isUTF16LE(data);\n        i = 0;\n      }\n\n      continue;\n    }\n\n    if (isLE) {\n      results[results.length] = c2;\n      results[results.length] = c1;\n    } else {\n      results[results.length] = c1;\n      results[results.length] = c2;\n    }\n  }\n\n  return results;\n}\n\nexports.UTF16ToUTF16BE = UTF16ToUTF16BE;\n/**\n * UTF-16BE to UTF-16\n */\n\nfunction UTF16BEToUTF16(data, options) {\n  var isLE = false;\n  var bom;\n\n  if (options && options.bom) {\n    var optBom = options.bom;\n\n    if (!util.isString(optBom)) {\n      optBom = 'BE';\n    }\n\n    if (optBom.charAt(0).toUpperCase() === 'B') {\n      // Big-endian\n      bom = [0xFE, 0xFF];\n    } else {\n      // Little-endian\n      bom = [0xFF, 0xFE];\n      isLE = true;\n    }\n  }\n\n  var results = [];\n  var len = data && data.length;\n  var i = 0;\n\n  if (len >= 2 && (data[0] === 0xFE && data[1] === 0xFF || data[0] === 0xFF && data[1] === 0xFE)) {\n    i = 2;\n  }\n\n  if (bom) {\n    results[0] = bom[0];\n    results[1] = bom[1];\n  }\n\n  var c1, c2;\n\n  while (i < len) {\n    c1 = data[i++];\n    c2 = data[i++];\n\n    if (isLE) {\n      results[results.length] = c2;\n      results[results.length] = c1;\n    } else {\n      results[results.length] = c1;\n      results[results.length] = c2;\n    }\n  }\n\n  return results;\n}\n\nexports.UTF16BEToUTF16 = UTF16BEToUTF16;\n/**\n * UTF-16 to UTF-16LE\n */\n\nfunction UTF16ToUTF16LE(data) {\n  var results = [];\n  var i = 0;\n  var len = data && data.length;\n  var isLE = false;\n  var first = true;\n  var c1, c2;\n\n  while (i < len) {\n    c1 = data[i++];\n    c2 = data[i++];\n\n    if (first && i === 2) {\n      first = false;\n\n      if (c1 === 0xFE && c2 === 0xFF) {\n        isLE = false;\n      } else if (c1 === 0xFF && c2 === 0xFE) {\n        // Little-endian\n        isLE = true;\n      } else {\n        isLE = EncodingDetect.isUTF16LE(data);\n        i = 0;\n      }\n\n      continue;\n    }\n\n    if (isLE) {\n      results[results.length] = c1;\n      results[results.length] = c2;\n    } else {\n      results[results.length] = c2;\n      results[results.length] = c1;\n    }\n  }\n\n  return results;\n}\n\nexports.UTF16ToUTF16LE = UTF16ToUTF16LE;\n/**\n * UTF-16LE to UTF-16\n */\n\nfunction UTF16LEToUTF16(data, options) {\n  var isLE = false;\n  var bom;\n\n  if (options && options.bom) {\n    var optBom = options.bom;\n\n    if (!util.isString(optBom)) {\n      optBom = 'BE';\n    }\n\n    if (optBom.charAt(0).toUpperCase() === 'B') {\n      // Big-endian\n      bom = [0xFE, 0xFF];\n    } else {\n      // Little-endian\n      bom = [0xFF, 0xFE];\n      isLE = true;\n    }\n  }\n\n  var results = [];\n  var len = data && data.length;\n  var i = 0;\n\n  if (len >= 2 && (data[0] === 0xFE && data[1] === 0xFF || data[0] === 0xFF && data[1] === 0xFE)) {\n    i = 2;\n  }\n\n  if (bom) {\n    results[0] = bom[0];\n    results[1] = bom[1];\n  }\n\n  var c1, c2;\n\n  while (i < len) {\n    c1 = data[i++];\n    c2 = data[i++];\n\n    if (isLE) {\n      results[results.length] = c1;\n      results[results.length] = c2;\n    } else {\n      results[results.length] = c2;\n      results[results.length] = c1;\n    }\n  }\n\n  return results;\n}\n\nexports.UTF16LEToUTF16 = UTF16LEToUTF16;\n/**\n * UTF-16BE to UTF-16LE\n */\n\nfunction UTF16BEToUTF16LE(data) {\n  var results = [];\n  var i = 0;\n  var len = data && data.length;\n  var c1, c2;\n\n  if (len >= 2 && (data[0] === 0xFE && data[1] === 0xFF || data[0] === 0xFF && data[1] === 0xFE)) {\n    i = 2;\n  }\n\n  while (i < len) {\n    c1 = data[i++];\n    c2 = data[i++];\n    results[results.length] = c2;\n    results[results.length] = c1;\n  }\n\n  return results;\n}\n\nexports.UTF16BEToUTF16LE = UTF16BEToUTF16LE;\n/**\n * UTF-16LE to UTF-16BE\n */\n\nfunction UTF16LEToUTF16BE(data) {\n  return UTF16BEToUTF16LE(data);\n}\n\nexports.UTF16LEToUTF16BE = UTF16LEToUTF16BE;\n/**\n * UTF-16 (JavaScript Unicode array) to JIS\n */\n\nfunction UNICODEToJIS(data) {\n  return UTF8ToJIS(UNICODEToUTF8(data));\n}\n\nexports.UNICODEToJIS = UNICODEToJIS;\n/**\n * JIS to UTF-16 (JavaScript Unicode array)\n */\n\nfunction JISToUNICODE(data) {\n  return UTF8ToUNICODE(JISToUTF8(data));\n}\n\nexports.JISToUNICODE = JISToUNICODE;\n/**\n * UTF-16 (JavaScript Unicode array) to EUCJP\n */\n\nfunction UNICODEToEUCJP(data) {\n  return UTF8ToEUCJP(UNICODEToUTF8(data));\n}\n\nexports.UNICODEToEUCJP = UNICODEToEUCJP;\n/**\n * EUCJP to UTF-16 (JavaScript Unicode array)\n */\n\nfunction EUCJPToUNICODE(data) {\n  return UTF8ToUNICODE(EUCJPToUTF8(data));\n}\n\nexports.EUCJPToUNICODE = EUCJPToUNICODE;\n/**\n * UTF-16 (JavaScript Unicode array) to SJIS\n */\n\nfunction UNICODEToSJIS(data) {\n  return UTF8ToSJIS(UNICODEToUTF8(data));\n}\n\nexports.UNICODEToSJIS = UNICODEToSJIS;\n/**\n * SJIS to UTF-16 (JavaScript Unicode array)\n */\n\nfunction SJISToUNICODE(data) {\n  return UTF8ToUNICODE(SJISToUTF8(data));\n}\n\nexports.SJISToUNICODE = SJISToUNICODE;\n/**\n * UTF-8 to UTF-16\n */\n\nfunction UTF8ToUTF16(data, options) {\n  return UNICODEToUTF16(UTF8ToUNICODE(data), options);\n}\n\nexports.UTF8ToUTF16 = UTF8ToUTF16;\n/**\n * UTF-16 to UTF-8\n */\n\nfunction UTF16ToUTF8(data) {\n  return UNICODEToUTF8(UTF16ToUNICODE(data));\n}\n\nexports.UTF16ToUTF8 = UTF16ToUTF8;\n/**\n * UTF-8 to UTF-16BE\n */\n\nfunction UTF8ToUTF16BE(data) {\n  return UNICODEToUTF16BE(UTF8ToUNICODE(data));\n}\n\nexports.UTF8ToUTF16BE = UTF8ToUTF16BE;\n/**\n * UTF-16BE to UTF-8\n */\n\nfunction UTF16BEToUTF8(data) {\n  return UNICODEToUTF8(UTF16BEToUNICODE(data));\n}\n\nexports.UTF16BEToUTF8 = UTF16BEToUTF8;\n/**\n * UTF-8 to UTF-16LE\n */\n\nfunction UTF8ToUTF16LE(data) {\n  return UNICODEToUTF16LE(UTF8ToUNICODE(data));\n}\n\nexports.UTF8ToUTF16LE = UTF8ToUTF16LE;\n/**\n * UTF-16LE to UTF-8\n */\n\nfunction UTF16LEToUTF8(data) {\n  return UNICODEToUTF8(UTF16LEToUNICODE(data));\n}\n\nexports.UTF16LEToUTF8 = UTF16LEToUTF8;\n/**\n * JIS to UTF-16\n */\n\nfunction JISToUTF16(data, options) {\n  return UTF8ToUTF16(JISToUTF8(data), options);\n}\n\nexports.JISToUTF16 = JISToUTF16;\n/**\n * UTF-16 to JIS\n */\n\nfunction UTF16ToJIS(data) {\n  return UTF8ToJIS(UTF16ToUTF8(data));\n}\n\nexports.UTF16ToJIS = UTF16ToJIS;\n/**\n * JIS to UTF-16BE\n */\n\nfunction JISToUTF16BE(data) {\n  return UTF8ToUTF16BE(JISToUTF8(data));\n}\n\nexports.JISToUTF16BE = JISToUTF16BE;\n/**\n * UTF-16BE to JIS\n */\n\nfunction UTF16BEToJIS(data) {\n  return UTF8ToJIS(UTF16BEToUTF8(data));\n}\n\nexports.UTF16BEToJIS = UTF16BEToJIS;\n/**\n * JIS to UTF-16LE\n */\n\nfunction JISToUTF16LE(data) {\n  return UTF8ToUTF16LE(JISToUTF8(data));\n}\n\nexports.JISToUTF16LE = JISToUTF16LE;\n/**\n * UTF-16LE to JIS\n */\n\nfunction UTF16LEToJIS(data) {\n  return UTF8ToJIS(UTF16LEToUTF8(data));\n}\n\nexports.UTF16LEToJIS = UTF16LEToJIS;\n/**\n * EUC-JP to UTF-16\n */\n\nfunction EUCJPToUTF16(data, options) {\n  return UTF8ToUTF16(EUCJPToUTF8(data), options);\n}\n\nexports.EUCJPToUTF16 = EUCJPToUTF16;\n/**\n * UTF-16 to EUC-JP\n */\n\nfunction UTF16ToEUCJP(data) {\n  return UTF8ToEUCJP(UTF16ToUTF8(data));\n}\n\nexports.UTF16ToEUCJP = UTF16ToEUCJP;\n/**\n * EUC-JP to UTF-16BE\n */\n\nfunction EUCJPToUTF16BE(data) {\n  return UTF8ToUTF16BE(EUCJPToUTF8(data));\n}\n\nexports.EUCJPToUTF16BE = EUCJPToUTF16BE;\n/**\n * UTF-16BE to EUC-JP\n */\n\nfunction UTF16BEToEUCJP(data) {\n  return UTF8ToEUCJP(UTF16BEToUTF8(data));\n}\n\nexports.UTF16BEToEUCJP = UTF16BEToEUCJP;\n/**\n * EUC-JP to UTF-16LE\n */\n\nfunction EUCJPToUTF16LE(data) {\n  return UTF8ToUTF16LE(EUCJPToUTF8(data));\n}\n\nexports.EUCJPToUTF16LE = EUCJPToUTF16LE;\n/**\n * UTF-16LE to EUC-JP\n */\n\nfunction UTF16LEToEUCJP(data) {\n  return UTF8ToEUCJP(UTF16LEToUTF8(data));\n}\n\nexports.UTF16LEToEUCJP = UTF16LEToEUCJP;\n/**\n * SJIS to UTF-16\n */\n\nfunction SJISToUTF16(data, options) {\n  return UTF8ToUTF16(SJISToUTF8(data), options);\n}\n\nexports.SJISToUTF16 = SJISToUTF16;\n/**\n * UTF-16 to SJIS\n */\n\nfunction UTF16ToSJIS(data) {\n  return UTF8ToSJIS(UTF16ToUTF8(data));\n}\n\nexports.UTF16ToSJIS = UTF16ToSJIS;\n/**\n * SJIS to UTF-16BE\n */\n\nfunction SJISToUTF16BE(data) {\n  return UTF8ToUTF16BE(SJISToUTF8(data));\n}\n\nexports.SJISToUTF16BE = SJISToUTF16BE;\n/**\n * UTF-16BE to SJIS\n */\n\nfunction UTF16BEToSJIS(data) {\n  return UTF8ToSJIS(UTF16BEToUTF8(data));\n}\n\nexports.UTF16BEToSJIS = UTF16BEToSJIS;\n/**\n * SJIS to UTF-16LE\n */\n\nfunction SJISToUTF16LE(data) {\n  return UTF8ToUTF16LE(SJISToUTF8(data));\n}\n\nexports.SJISToUTF16LE = SJISToUTF16LE;\n/**\n * UTF-16LE to SJIS\n */\n\nfunction UTF16LEToSJIS(data) {\n  return UTF8ToSJIS(UTF16LEToUTF8(data));\n}\n\nexports.UTF16LEToSJIS = UTF16LEToSJIS;","map":null,"metadata":{},"sourceType":"module"}